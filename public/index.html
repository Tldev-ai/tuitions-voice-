<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>iiTuitions — Voice</title>
  <style>
    :root{ --ink:#0b1220; --ring:#e5e7eb; --muted:#4b5563; --ok:#10b981; --idle:#9ca3af; }
    *{box-sizing:border-box} body{margin:0;font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Inter,sans-serif;color:var(--ink);background:#fff}
    .top{display:flex;align-items:center;gap:10px;border-bottom:1px solid var(--ring);padding:12px 16px}
    .brand{display:flex;align-items:center;gap:8px;text-decoration:none;color:var(--ink);font-weight:800}
    .wrap{max-width:760px;margin:28px auto;padding:0 16px}
    .card{padding:24px;border:1px solid var(--ring);border-radius:16px;box-shadow:0 6px 28px rgba(0,0,0,.06)}
    h1{margin:0 0 10px}
    .consent{display:flex;align-items:center;gap:8px;color:var(--muted);margin-top:10px}
    .row{display:flex;gap:12px;align-items:center;margin-top:12px;flex-wrap:wrap}
    button{display:inline-flex;gap:8px;align-items:center;padding:12px 16px;border-radius:999px;border:0;background:#111;color:#fff;font-weight:800;cursor:pointer}
    button.end{background:#ef4444}
    button:disabled{opacity:.6;cursor:not-allowed}
    .fine{font-size:12px;color:#6b7280;margin-top:8px}
    audio{display:none}
    .led{width:10px;height:10px;border-radius:999px;background:var(--idle);box-shadow:0 0 0 1px #00000010}
    .led.on{background:var(--ok)}
  </style>
</head>
<body>
  <header class="top">
    <a class="brand" href="#"><img src="/assets/iituitions-logo.png" alt="logo" style="height:24px"> iiTuitions</a>
  </header>

  <main class="wrap">
    <section class="card">
      <h1>Talk to our Admissions Assistant</h1>
      <p>Click below to speak. Your conversation is recorded (audio + summary) for follow-up.</p>

      <label class="consent">
        <input type="checkbox" id="consent" />
        I agree to the recording and storage of this conversation.
      </label>

      <div class="row">
        <button id="startBtn">Start Voice</button>
        <button id="endBtn" class="end" disabled>End</button>
        <span class="led" id="led" title="Mic activity"></span>
        <audio id="aiAudio" autoplay playsinline></audio>
      </div>

      <div class="fine">Tip: use headphones to avoid echo.</div>
      <pre id="log" style="display:none"></pre>
    </section>
  </main>

  <script>
    const startBtn = document.getElementById('startBtn');
    const endBtn   = document.getElementById('endBtn');
    const aiAudio  = document.getElementById('aiAudio');
    const consent  = document.getElementById('consent');
    const led      = document.getElementById('led');

    let pc, dc, localStream, remoteStream, mediaRecorder, recordedChunks = [];
    let silenceRAF, silenceTimer, analyser, dataArray;

    const SILENCE_MS = 15000;
    const RMS_THRESHOLD = 0.006;

    function timeOfDay(){ const h=new Date().getHours(); return h<12?'morning':h<17?'afternoon':h<21?'evening':'night'; }

    async function startCall() {
      if (!consent.checked) { alert('Please provide consent to proceed.'); return; }
      startBtn.disabled = true; endBtn.disabled = false;

      // Get ephemeral session
      const resp = await fetch('/session');
      if (!resp.ok) {
        const err = await resp.json().catch(()=>({}));
        alert('Failed to create realtime session' + (err?.error?.message ? (':\n' + err.error.message) : ''));
        startBtn.disabled=false; endBtn.disabled=true; return;
      }
      const sess = await resp.json();
      const EPHEMERAL = sess.client_secret.value;
      const MODEL = encodeURIComponent(sess.model || 'gpt-4o-realtime-preview');

      // PeerConnection
      pc = new RTCPeerConnection();
      dc = pc.createDataChannel('oai-events');

      // Proactive greeting (Hai + time + language)
      dc.onopen = () => {
        const greet = `Hai. Good ${timeOfDay()}. Which language would you like to talk in — English, తెలుగు (Telugu), or हिन्दी (Hindi)?`;
        try { dc.send(JSON.stringify({ type:'response.create', response:{ instructions:greet } })); } catch {}
      };

      // Mic
      try {
        localStream = await navigator.mediaDevices.getUserMedia({
          audio: { echoCancellation:true, noiseSuppression:true, autoGainControl:true }
        });
      } catch {
        alert('Microphone blocked. Click the mic icon in the address bar and Allow, then reload.');
        startBtn.disabled=false; endBtn.disabled=true; return;
      }
      localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

      // Playback + recording + silence detection
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const dest = ctx.createMediaStreamDestination();

      pc.ontrack = (ev) => {
        remoteStream = ev.streams[0];
        aiAudio.srcObject = remoteStream;

        const micSrc = ctx.createMediaStreamSource(localStream);
        const aiSrc  = ctx.createMediaStreamSource(remoteStream);
        micSrc.connect(dest); aiSrc.connect(dest);

        // silence detector (on mic)
        analyser = ctx.createAnalyser(); analyser.fftSize = 2048;
        const micTap = ctx.createMediaStreamSource(localStream);
        micTap.connect(analyser);
        dataArray = new Float32Array(analyser.fftSize);

        const resetSilence = () => {
          if (silenceTimer) clearTimeout(silenceTimer);
          silenceTimer = setTimeout(() => {
            try {
              dc?.send(JSON.stringify({ type:'response.create', response:{ instructions:"Sorry, I'm unable to hear you. I'll end this call now." } }));
            } catch {}
            setTimeout(endCall, 1800);
          }, SILENCE_MS);
        };

        const monitor = () => {
          analyser.getFloatTimeDomainData(dataArray);
          let rms = 0; for (let i=0;i<dataArray.length;i++){ const v=dataArray[i]; rms += v*v; }
          rms = Math.sqrt(rms / dataArray.length);
          if (rms > RMS_THRESHOLD) { led.classList.add('on'); resetSilence(); }
          else { led.classList.remove('on'); }
          silenceRAF = requestAnimationFrame(monitor);
        };
        setTimeout(()=>{ resetSilence(); monitor(); }, 1200);

        // Recorder (mix mic + AI)
        try { mediaRecorder = new MediaRecorder(dest.stream, { mimeType: 'audio/webm;codecs=opus' }); }
        catch { mediaRecorder = new MediaRecorder(dest.stream); }
        mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) recordedChunks.push(e.data); };
        mediaRecorder.start(250);
      };

      // SDP offer/answer
      const offer = await pc.createOffer(); await pc.setLocalDescription(offer);
      await new Promise((resolve) => {
        if (pc.iceGatheringState === 'complete') return resolve();
        pc.onicegatheringstatechange = () => { if (pc.iceGatheringState === 'complete') resolve(); };
      });
      const sdpResp = await fetch(`https://api.openai.com/v1/realtime?model=${MODEL}`, {
        method: 'POST',
        headers: { 'Authorization': `Bearer ${EPHEMERAL}`, 'Content-Type': 'application/sdp' },
        body: pc.localDescription.sdp
      });
      const answer = { type: 'answer', sdp: await sdpResp.text() };
      await pc.setRemoteDescription(answer);
    }

    async function endCall() {
      endBtn.disabled = true;
      try { if (silenceTimer) clearTimeout(silenceTimer); if (silenceRAF) cancelAnimationFrame(silenceRAF); } catch {}
      try { mediaRecorder && mediaRecorder.stop(); } catch {}
      try { pc && pc.close(); } catch {}
      try { localStream && localStream.getTracks().forEach(t => t.stop()); } catch {}

      // Upload
      const audioBlob = new Blob(recordedChunks, { type: 'audio/webm' });
      const form = new FormData();
      form.append('audio', audioBlob, 'conversation.webm');
      form.append('transcriptJson', JSON.stringify({ endedAt: new Date().toISOString() }));

      try { await fetch('/upload', { method: 'POST', body: form }); } catch {}
      startBtn.disabled = false; recordedChunks = [];
    }

    startBtn.addEventListener('click', startCall);
    endBtn.addEventListener('click', endCall);
  </script>
</body>
</html>
